%{
#include <string>
#include <iostream>
#include <typeinfo>
#include <memory>

#include "includeCommun.h"

using namespace AST;

extern int yylex(void);
void yyerror(long int * param, const char * msg);

std::shared_ptr<Scope> global = std::make_shared<Scope>();

std::shared_ptr<Scope> currentContext = global;

%}

%union {
	char cVal;
	long int lVal;
	char * sVal;
	char * id;
	long int eval;
	AST::AbstractExpression* evalExpression;
	
	AST::Block* block;
	
	AST::ComposedInstruction* compInstruction; 
	AST::UnitInstruction* unitInstruction;
	AST::AbstractInstruction* abstractInstruction;
	AST::SequenceInstruction* sequenceInstruction;
	
	AST::VariableSignature* signatureV;
	AST::Type* typeVar;
	AST::VariableDeclaration* declVar;
	enum AST::OPAffect* op;
	
        AST::FunctionSignature* signatureF;
	AST::LArguments* fctArguments;
        AST::FunctionDeclaration* declFct;
        AST::Function* fct;
	AST::LParametres* params;
        AST::FunctionCall * appelFct;
}

%token SHARP LINE_COM BEGIN_COM END_COM 
%token IF ELSE WHILE FOR MAIN 
%token LEFT_BRACES RIGHT_BRACES LEFT_PARENTHESIS RIGHT_PARENTHESIS 
%token LEFT_BRACKET RIGHT_BRACKET BOOL_EQUAL RETURN 
%token BOOL_DIF BOOL_LESS_OR_EQUAL BOOL_GREATER_OR_EQUAL BOOL_LESS BOOL_GREATER 
%token AFFECT_ADD AFFECT_SUB AFFECT_MULT AFFECT_DIV AFFECT_MOD TERNARY_ASK TERNARY_CHOOSE
%token AFFECT_BIT_LEFT_SHIFT AFFECT_BIT_RIGHT_SHIFT
%token AFFECT_BIT_AND AFFECT_BIT_XOR AFFECT_BIT_OR
%token INCREMENT DECREMENT AFFECT ADD SUB MULT DIV MOD 
%token BOOL_AND BOOL_OR BOOL_NOT BIT_AND BIT_OR BIT_XOR
%token BIT_NOT BIT_LEFT_SHIFT BIT_RIGHT_SHIFT 
%token VOID CHAR INT32 INT64 SEMICOLON COMMA UNEXPECTED
%token <cVal> CHAR_VAL
%token <lVal> INT_VAL
%token <sVal> CHAIN
%token <id> ID

%type <evalExpression> expr
%type <evalExpression> uoperation
%type <evalExpression> affectation

%type <compInstruction> iintcomp
%type <unitInstruction> iintunit
%type <abstractInstruction> iint iext
%type <sequenceInstruction> seqint liext

%type <block> bloc

%type <signatureV> sigvar arg
%type <typeVar> type maintype
%type <declVar> declvar
%type <op> signeaff

%type <signatureF> sigfonc
%type <fctArguments> larg mainarg
%type <declFct> declfonc deffonc mainbody
%type <fct> debutfonc maindecl
%type <params> lparam
%type <appelFct> appelfonc

%left ID
%right AFFECT AFFECT_ADD AFFECT_SUB AFFECT_MULT AFFECT_DIV AFFECT_MOD AFFECT_BIT_LEFT_SHIFT AFFECT_BIT_RIGHT_SHIFT AFFECT_BIT_AND AFFECT_BIT_XOR AFFECT_BIT_OR
%left COMMA
%right TERNARY_ASK TERNARY_CHOOSE
%left BOOL_OR
%left BOOL_AND
%left BIT_OR
%left BIT_XOR
%left BIT_AND
%left BOOL_EQUAL BOOL_DIF
%left BOOL_LESS BOOL_GREATER BOOL_LESS_OR_EQUAL BOOL_GREATER_OR_EQUAL 
%left BIT_RIGHT_SHIFT BIT_LEFT_SHIFT
%left ADD SUB
%left MULT DIV MOD
%right BIT_NOT BOOL_NOT INCREMENT DECREMENT
%right SEMICOLON

%expect 1 // conflit if 			

%parse-param{long int *renvoi}


%%

/* ===== TODO: TO SORT ===== */



/* ===== GENERAL ===== */ // TODO

programme : liext mainbody liext {std::cout << std::endl << "==== PRINT TREE ====" << std::endl; $1->printTree(0); $2->printTree(0); $3->printTree(0); delete $1; delete $2; delete $3;}
    ;
    
mainbody : maindecl bloc {$1->setBlock(std::make_shared<Block>( *( static_cast< Block* >($2))));
                                                        $$ = new FunctionDeclaration($1->getSignature(), std::make_shared<Function>( *( static_cast< Function* >($1))), currentContext->getMother());
							delete $1;
							delete $2;
							currentContext = currentContext->getMother();}
	;

maindecl : maintype MAIN LEFT_PARENTHESIS mainarg RIGHT_PARENTHESIS {if($4 != nullptr)
																		{
                                                                                                                                                        $$ = new Function(std::make_shared<FunctionSignature>("main", *$1),
																					std::make_shared<LArguments>( *( static_cast< LArguments* >($4))), currentContext);	
																			delete $1;
																			delete $4;
																		}
																		else
																		{
                                                                                                                                                        $$ = new Function(std::make_shared<FunctionSignature>("main", *$1), currentContext);
																			delete $1;	
																		}			
																		currentContext = $$->getScope();
																	}
    ;
maintype : type         {$$ = $1;}
    | VOID              {$$ = new Type(Type::ERROR);}
    | /* epsilon */     {$$ = new Type(Type::ERROR);}
    ;
mainarg : VOID          {$$ = nullptr;}
    | larg              {$$ = $1;}
    | /* epsilon */     {$$ = nullptr;}
    ;
    
liext : liext iext  {$$->addInstruction(make_shared_instr($2)); delete $2;}
    | SEMICOLON {$$->addInstruction(std::make_shared<ComposedInstruction>());} 
	| /*epsilon*/ {$$ = new SequenceInstruction();} 
	;
iext : deffonc    {$$ = $1;}
    | declfonc    {$$ = $1;}
    | declvar   {$$ = $1;}
    ;

/* ===== FONCTIONS ======*/ // TODO

declfonc : debutfonc SEMICOLON  {$$ = new FunctionDeclaration($1->getSignature(), std::make_shared<Function>( *( static_cast< Function* >($1))), currentContext->getMother());
									delete $1;
									currentContext = currentContext->getMother();}
    ;
deffonc : debutfonc bloc        {$1->setBlock(std::make_shared<Block>( *( static_cast< Block* >($2))));
                                                                        $$ = new FunctionDeclaration($1->getSignature(), std::make_shared<Function>( *( static_cast< Function* >($1))), currentContext->getMother());
									delete $1;
									delete $2;
									currentContext = currentContext->getMother();
								}
    ;
    
debutfonc : sigfonc larg RIGHT_PARENTHESIS     {$$ = new Function(std::make_shared<FunctionSignature>( *( static_cast< FunctionSignature* >($1))),
																				std::make_shared<LArguments>( *( static_cast< LArguments* >($2))), currentContext);
												delete $1;
												delete $2;
												currentContext = $$->getScope();
												}
    | sigfonc RIGHT_PARENTHESIS                {$$ = new Function(std::make_shared<FunctionSignature>( *( static_cast< FunctionSignature* >($1))), currentContext);
												delete $1;
												currentContext = $$->getScope();
												}
    | sigfonc VOID RIGHT_PARENTHESIS           {$$ = new Function(std::make_shared<FunctionSignature>( *( static_cast< FunctionSignature* >($1))), currentContext);
												delete $1;
												currentContext = $$->getScope();
												}
    ;
    
larg : larg COMMA arg                               {$$->addArgument(std::make_shared<VariableSignature>( *( static_cast< VariableSignature* >($3))));
														delete $3;}
    | larg COMMA type                               {$$->addArgument(std::make_shared<VariableSignature>("", *$3));
    													delete $3;}
    | larg COMMA type LEFT_BRACKET RIGHT_BRACKET    {std::cout << "larg : larg , type [ ] "<< std::endl;}
    | arg                                           {$$ = new LArguments(std::make_shared<VariableSignature>( *( static_cast< VariableSignature* >($1) )));
    													delete $1;}
    | type                                          {$$ = new LArguments(std::make_shared<VariableSignature>("", *$1));
    													delete $1;}
    | type LEFT_BRACKET RIGHT_BRACKET               {std::cout << "larg : type[] "<< std::endl;}
    ;
arg : sigvar                                {$$ = $1;}
    | sigvar LEFT_BRACKET RIGHT_BRACKET     {std::cout << "arg : sigvar[] "<< std::endl;}
    ;
    
appelfonc :ID LEFT_PARENTHESIS RIGHT_PARENTHESIS    {$$ = new FunctionCall($1, nullptr, currentContext);}
    | ID LEFT_PARENTHESIS lparam RIGHT_PARENTHESIS  {$$ = new FunctionCall($1, std::make_shared<LParametres>( *( static_cast< LParametres* >($3) )), currentContext);
    													delete $3;}
    ;
lparam : lparam COMMA expr    {$$->addParametre(make_shared_expr($3));}
    | expr                    {$$ = new LParametres(make_shared_expr($1));}
    ;
    

/* ===== VARIABLES ===== */ // TODO

declvar : sigvar AFFECT expr    {$$ = new VariableDeclaration(std::make_shared<VariableSignature>( *( static_cast< VariableSignature* >($1) )), make_shared_expr($3), currentContext);
									delete $1;
									delete $3;}
	| sigvar                    {$$ = new VariableDeclaration(std::make_shared<VariableSignature>( *( static_cast< VariableSignature* >($1) )), currentContext);
									delete $1;}
	;

type : CHAR {$$ = new Type(Type::CHAR);}
	| INT32 {$$ = new Type(Type::INT_32);}
	| INT64	{$$ = new Type(Type::INT_64);}
	;

/* ===== IDENTIFIANT ===== */ 

sigvar : type ID {$$ = new VariableSignature($2, *$1);
					delete $1;}
	;
	
sigfonc : type ID LEFT_PARENTHESIS          {$$ = new FunctionSignature($2, *$1);
												delete $1;} // TODO
    | VOID ID LEFT_PARENTHESIS                              {$$ = new FunctionSignature($2);}
    | type LEFT_BRACKET RIGHT_BRACKET ID LEFT_PARENTHESIS   {std::cout << "sigfonc : type [] ID"<< std::endl;} // TODO
    ;

/* ===== INSTRUCTIONS INTERIEURES ===== */

open_context : LEFT_BRACES {currentContext = std::make_shared<Scope>(currentContext);}
	;
	
close_context : RIGHT_BRACES {currentContext = currentContext->getMother();}

bloc : open_context seqint close_context    {$$ = new Block(currentContext, std::make_shared<SequenceInstruction>( *( static_cast< SequenceInstruction* >($2) )));}
    ;

seqint : seqint iint {$$->addInstruction(make_shared_instr($2)); delete $2;} 
	|  seqint declvar SEMICOLON {$$->addInstruction(make_shared_instr($2)); delete $2;}
	| seqint declfonc {$$->addInstruction(make_shared_instr($2)); delete $2;} 
	| SEMICOLON {$$->addInstruction(std::make_shared<ComposedInstruction>());} 
	| /*epsilon*/ {$$ = new SequenceInstruction();} 
	;
	
iint : iintcomp SEMICOLON {$$ = $1;}
	| iintunit {$$ = $1;}
	;

iintunit : bloc {$$ = new UnitInstruction(std::make_shared<Block>( *( static_cast< Block* >($1) ) ));
					delete $1;}
	| structure {$$ = new UnitInstruction();} // TODO
	| ireturn {$$ = new UnitInstruction();} // TODO
	;
	
ireturn : RETURN iintcomp SEMICOLON {} // TODO
	| RETURN SEMICOLON {} // TODO
	;
	
iintcomp : iintcomp COMMA expr {$$ = $1; 
								$$->addExpression(make_shared_expr($3)); 
								delete $3;}
	| expr TERNARY_ASK iintcomp TERNARY_CHOOSE iintcomp {$$ = new ComposedInstruction(make_shared_expr($1)); delete $1; delete $3; delete $5;} // TODO
	| expr {$$ = new ComposedInstruction(make_shared_expr($1));
			delete $1;}
	;

/* ===== EXPRESSION ===== */ // TODO

uoperation : SUB expr {$$ = new Constant(-1*($2->evaluate().getValue().second));
						delete $2;}
	| ADD expr {$$ = new Constant(($2->evaluate().getValue().second));
				delete $2;}
	| BIT_NOT expr {$$ = new Constant(~($2->evaluate().getValue().second));
					delete $2;}
	| BOOL_NOT expr {long int i = 0;
					if($2->evaluate().getValue().second == 0)
							i = 1;
					$$ = new Constant(i);
					delete $2;}
	;
	
expr : INT_VAL {$$ = new Constant($1);}
	| ID {$$ = new IDExpression($1, currentContext);}
	| uoperation {$$ = $1;} // TODO
	| affectation {$$ = $1;} // TODO
	| appelfonc {$$ = $1;}
	| expr BOOL_OR expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr BOOL_AND expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO 
								delete $1;
								delete $3;}
	| expr BIT_OR expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr BIT_XOR expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr BIT_AND expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr BOOL_EQUAL expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr BOOL_DIF expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr BOOL_LESS expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr BOOL_GREATER expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr BOOL_LESS_OR_EQUAL expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr BOOL_GREATER_OR_EQUAL expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr BIT_RIGHT_SHIFT expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr BIT_LEFT_SHIFT expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr ADD expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3));
								delete $1;
								delete $3;}
	| expr SUB expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr MULT expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr DIV expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| expr MOD expr {$$ = new AddExpression(make_shared_expr($1), make_shared_expr($3)); // TODO
								delete $1;
								delete $3;}
	| LEFT_PARENTHESIS iintcomp RIGHT_PARENTHESIS {$$ = new Constant($2->evaluate().getValue().second); delete $2;} // TODO rajouter constructeur pour constante
	;

/* ===== AFFECTATION ===== */ // TODO

affectation : ID signeaff expr {$$ = new AffectationExpression($1, *$2, make_shared_expr($3), currentContext); 
								delete $2;
								delete $3;}
	;
	
signeaff : AFFECT {$$ = new OPAffect(OPAffect::AFFECT);}
	| AFFECT_MULT {$$ = new OPAffect(OPAffect::AFFECT_MULT);} 
	| AFFECT_DIV  {$$ = new OPAffect(OPAffect::AFFECT_DIV);}
	| AFFECT_ADD  {$$ = new OPAffect(OPAffect::AFFECT_ADD);}
	| AFFECT_SUB  {$$ = new OPAffect(OPAffect::AFFECT_SUB);}
	| AFFECT_MOD  {$$ = new OPAffect(OPAffect::AFFECT_MOD);}
	| AFFECT_BIT_AND  {$$ = new OPAffect(OPAffect::AFFECT_BIT_AND);}
	| AFFECT_BIT_OR  {$$ = new OPAffect(OPAffect::AFFECT_BIT_OR);}
	| AFFECT_BIT_XOR   {$$ = new OPAffect(OPAffect::AFFECT_BIT_XOR);}
	| AFFECT_BIT_LEFT_SHIFT  {$$ = new OPAffect(OPAffect::AFFECT_BIT_LEFT_SHIFT);}
	| AFFECT_BIT_RIGHT_SHIFT {$$ = new OPAffect(OPAffect::AFFECT_BIT_RIGHT_SHIFT);}
	;

/* ===== STRUCTURES ===== */  // TODO

structure :  structureif { }
	| structurewhile { } 
	| structurefor { } 
	;

structureif : IF LEFT_PARENTHESIS iintcomp RIGHT_PARENTHESIS iint structureelse { std::cout << "IF ( IIntComp ) IInt "<< std::endl;}
	;

structureelse : ELSE iint {std::cout << "ELSE IInt "<< std::endl;}
	| /*epsilon*/ {}
	;
	
structurewhile : WHILE LEFT_PARENTHESIS iintcomp RIGHT_PARENTHESIS iint {std::cout << "WHILE ( IIntComp ) IInt "<< std::endl;}
	;

structurefor : FOR LEFT_PARENTHESIS ifor SEMICOLON ifor SEMICOLON ifor RIGHT_PARENTHESIS iint {std::cout << "FOR ( IFor ; IFor ; IFor ) IInt "<< std::endl;}
	;
	
ifor : iintcomp {}
	| /*epsilon*/ {}
	;

%%
void yyerror(long int * param, const char * msg)
{
    std::cout << msg << std::endl;
}
