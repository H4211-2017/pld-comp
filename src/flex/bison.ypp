%{
#include <map>
#include <string>
#include <iostream>
#include <typeinfo>
#include <memory>
//#include "Variable.h"
#include "TypeInt64.h"
#include "TypeInt32.h"
#include "TypeChar.h"
#include "fcBison.h"

using namespace std;

extern int yylex(void);
void yyerror(shared_ptr< mapVar > * param, const char * msg);

shared_ptr< mapVar > variablesGlob = make_shared< mapVar >();

%}

%union {
	char cVal;
	long int lVal;
	char * sVal;
	char * id;
	long int eval;
}

%token SHARP LINE_COM BEGIN_COM END_COM 
%token IF ELSE WHILE FOR MAIN 
%token LEFT_BRACES RIGHT_BRACES LEFT_PARENTHESIS RIGHT_PARENTHESIS 
%token LEFT_BRACKET RIGHT_BRACKET BOOL_EQUAL RETURN 
%token BOOL_DIF BOOL_LESS_OR_EQUAL BOOL_GREATER_OR_EQUAL BOOL_LESS BOOL_GREATER 
%token AFFECT_ADD AFFECT_SUB AFFECT_MULT AFFECT_DIV AFFECT_MOD TERNARY_ASK TERNARY_CHOOSE
%token INCREMENT DECREMENT AFFECT ADD SUB MULT DIV MOD 
%token BOOL_AND BOOL_OR BOOL_NOT BIT_AND BIT_OR BIT_XOR
%token BIT_NOT BIT_LEFT_SHIFT BIT_RIGHT_SHIFT 
%token VOID CHAR INT32 INT64 SEMICOLON COMMA UNEXPECTED
%token <cVal> CHAR_VAL
%token <lVal> INT_VAL
%token <sVal> CHAIN
%token <id> ID
%type <eval> expr
%type <eval> uoperation
%type <eval> iintcomp
%type <eval> iint
%type <eval> seqint

%left ID
%right AFFECT
%left COMMA
%right TERNARY_ASK TERNARY_CHOOSE
%left BOOL_OR
%left BOOL_AND
%left BIT_OR
%left BIT_XOR
%left BIT_AND
%left BOOL_EQUAL BOOL_DIF
%left BOOL_LESS BOOL_GREATER BOOL_LESS_OR_EQUAL BOOL_GREATER_OR_EQUAL 
%left BIT_RIGHT_SHIFT BIT_LEFT_SHIFT
%left ADD SUB
%left MULT DIV MOD
%right BIT_NOT BOOL_NOT
%left SEMICOLON

%parse-param{shared_ptr< mapVar > * renvoi}

%%

/* ===== TODO: TO SORT ===== */

result : seqint {InfosSigVar tps; createVariable(variablesGlob, tps); affectVariable(variablesGlob, "renvoi", $1); *renvoi = variablesGlob;}
	;

/* ===== GENERAL ===== */

programme : liext mainbody liext {std::cout << "programme" << std::endl;}
    ;
    
mainbody : maintype MAIN LEFT_PARENTHESIS mainarg RIGHT_PARENTHESIS bloc {std::cout << "mainbody" << std::endl;}
    ;
maintype : type         {std::cout << "maintype: type" << std::endl;}
    | VOID              {std::cout << "maintype : void" << std::endl;}
    | /* epsilon */     {std::cout << "maintype : epsilon" << std::endl;}
    ;
mainarg : VOID          {std::cout << "mainarg : void" << std::endl;}
    | larg              {std::cout << "mainarag : larg" << std::endl;}
    | /* epsilon */     {std::cout << "mainarg : epsilon" << std::endl;}
    ;
    
liext : liext iext  {std::cout << "liext : liext iext" << std::endl;}
    | /* epsilon */ {std::cout << "liext : epsilon" << std::endl;}
    ;
iext : deffonc    {std::cout << "iext : deffonc" << std::endl;}
    | declfonc    {std::cout << "iext : declfonc" << std::endl;}
    | SHARP     {std::cout << "iext : SHARP" << std::endl;}
    | declvar   {std::cout << "iext : declvar" << std::endl;}
    ;

/* ===== FONCTIONS ======*/

declfonc : debutfonc SEMICOLON  {std::cout << "declfonc : debutfonc ;" << std::endl;}
    ;
deffonc : debutfonc bloc        {std::cout << "deffonc : debutfonc bloc" << std::endl;}
    ;
    
debutfonc : sigfonc LEFT_PARENTHESIS larg RIGHT_PARENTHESIS     {std::cout << "debutfonc : sigfonc ( larg )" << std::endl;}
    | sigfonc LEFT_PARENTHESIS RIGHT_PARENTHESIS                {std::cout << "debutfonc : sigfonc ( )" << std::endl;}
    | sigfonc LEFT_PARENTHESIS VOID RIGHT_PARENTHESIS           {std::cout << "debutfonc : sigfonc ( VOID )" << std::endl;}
    ;
    
larg : larg COMMA arg                               {std::cout << "larg : larg , arg "<< std::endl;}
    | larg COMMA type                               {std::cout << "larg : larg , type "<< std::endl;}
    | larg COMMA type LEFT_BRACKET RIGHT_BRACKET    {std::cout << "larg : larg , type [ ] "<< std::endl;}
    | arg                                           {std::cout << "larg : arg "<< std::endl;}
    | type                                          {std::cout << "larg : type "<< std::endl;}
    | type LEFT_BRACKET RIGHT_BRACKET               {std::cout << "larg : type[] "<< std::endl;}
    ;
arg : sigvar                                {std::cout << "arg : sigvar "<< std::endl;}
    | sigvar LEFT_BRACKET RIGHT_BRACKET     {std::cout << "arg : sigvar[] "<< std::endl;}
    ;
    
appelfonc :ID LEFT_PARENTHESIS RIGHT_PARENTHESIS    {std::cout << "appelfonc : ID ( ) "<< std::endl;}
    | ID LEFT_PARENTHESIS lparam RIGHT_PARENTHESIS  {std::cout << "appelfonc : ID ( lparam )" << std::endl;}
    ;
lparam : lparam COMMA ID    {std::cout << "lparam : lparam, ID "<< std::endl;}
    | ID                    {std::cout << "lparam : ID "<< std::endl;}
    ;
    

/* ===== VARIABLES ===== */

declvar : sigvar AFFECT expr    {std::cout << "declvar : sigvar AFFECT expr "<< std::endl;}
	| sigvar                    {std::cout << "declvar : sigvar "<< std::endl;}
	;

type : CHAR {std::cout << "type : char "<< std::endl;}
	| INT32 {std::cout << "type : int32 "<< std::endl;}
	| INT64	{std::cout << "type : int64 "<< std::endl;}
	;

/* ===== IDENTIFIANT ===== */

sigvar : type ID {std::cout << "sigvar : type ID "<< std::endl;}
	;
	
sigfonc : type ID                           {std::cout << "sigfonc : type ID "<< std::endl;}
    | VOID ID                               {std::cout << "sigfonc : void ID "<< std::endl;}
    | type LEFT_BRACKET RIGHT_BRACKET ID    {std::cout << "sigfonc : type [] ID"<< std::endl;}
    | ID                                    {std::cout << "sigfonc : ID "<< std::endl;}
    ;

/* ===== INSTRUCTIONS INTERIEURES ===== */

bloc : LEFT_BRACKET seqint RIGHT_BRACKET    {std::cout << "bloc : { seqint } "<< std::endl;}
    ;

seqint : seqint iint {$$ = $2;}
	|  seqint declvar SEMICOLON {$$ = 0;}
	| /*epsilon*/ {$$ = 0;}
	;
	
iint : iintcomp SEMICOLON {$$ = $1;}
	;
	
iintcomp : iintcomp COMMA expr {$$ = $3;}
	| expr TERNARY_ASK iintcomp TERNARY_CHOOSE iintcomp {$$ = $1 ? $3 : $5;}
	| expr {$$ = $1;}
	;

/* ===== EXPRESSION ===== */

uoperation : SUB expr {$$ = -$2;}
	| ADD expr {$$ = $2;}
	| BIT_NOT expr {$$ = ~$2;}
	| BOOL_NOT expr {$$ = !$2;}
	;
	
expr : INT_VAL {$$ = $1;}
	| uoperation {$$ = $1;}
	| expr BOOL_OR expr {$$ = $1 || $3;}
	| expr BOOL_AND expr {$$ = $1 && $3;}
	| expr BIT_OR expr {$$ = $1 | $3;}
	| expr BIT_XOR expr {$$ = $1 ^ $3;}
	| expr BIT_AND expr {$$ = $1 & $3;}
	| expr BOOL_EQUAL expr {$$ = $1 == $3;}
	| expr BOOL_DIF expr {$$ = $1 != $3;}
	| expr BOOL_LESS expr {$$ = $1 < $3;}
	| expr BOOL_GREATER expr {$$ = $1 > $3;}
	| expr BOOL_LESS_OR_EQUAL expr {$$ = $1 <= $3;}
	| expr BOOL_GREATER_OR_EQUAL expr {$$ = $1 >= $3;}
	| expr BIT_RIGHT_SHIFT expr {$$ = $1 >> $3;}
	| expr BIT_LEFT_SHIFT expr {$$ = $1 << $3;}
	| expr ADD expr {$$ = $1 + $3;}
	| expr SUB expr {$$ = $1 - $3;}
	| expr MULT expr {$$ = $1 * $3;}
	| expr DIV expr {$$ = $1 / $3;}
	| expr MOD expr {$$ = $1 % $3;}
	| LEFT_PARENTHESIS iintcomp RIGHT_PARENTHESIS {$$ = $2;}
	;

/* ===== AFFECTATION ===== */

/* ===== STRUCTURES ===== */ 

%%
void yyerror(long int * param, const char * msg)
{
    std::cout << msg << std::endl;
}
