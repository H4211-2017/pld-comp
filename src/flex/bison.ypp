%{
#include <map>
#include <string>
#include <iostream>
#include <typeinfo>
#include <memory>

#include "Constant.h"
#include "AbstractExpression.h"
#include "AddExpression.h"
#include "AbstractNode.h"

using namespace AST;

extern int yylex(void);
void yyerror(int * param, const char * msg);

%}

%union {
	char cVal;
	long int lVal;
	char * sVal;
	char * id;
	long int eval;
	struct ExprNode * evalExpression;
}

%token SHARP LINE_COM BEGIN_COM END_COM 
%token IF ELSE WHILE FOR MAIN 
%token LEFT_BRACES RIGHT_BRACES LEFT_PARENTHESIS RIGHT_PARENTHESIS 
%token LEFT_BRACKET RIGHT_BRACKET BOOL_EQUAL RETURN 
%token BOOL_DIF BOOL_LESS_OR_EQUAL BOOL_GREATER_OR_EQUAL BOOL_LESS BOOL_GREATER 
%token AFFECT_ADD AFFECT_SUB AFFECT_MULT AFFECT_DIV AFFECT_MOD TERNARY_ASK TERNARY_CHOOSE
%token AFFECT_BIT_LEFT_SHIFT AFFECT_BIT_RIGHT_SHIFT
%token AFFECT_BIT_AND AFFECT_BIT_XOR AFFECT_BIT_OR
%token INCREMENT DECREMENT AFFECT ADD SUB MULT DIV MOD 
%token BOOL_AND BOOL_OR BOOL_NOT BIT_AND BIT_OR BIT_XOR
%token BIT_NOT BIT_LEFT_SHIFT BIT_RIGHT_SHIFT 
%token VOID CHAR INT32 INT64 SEMICOLON COMMA UNEXPECTED
%token <cVal> CHAR_VAL
%token <lVal> INT_VAL
%token <sVal> CHAIN
%token <id> ID
%type <evalExpression> expr
%type <evalExpression> uoperation
%type <eval> iintcomp
%type <eval> iint
%type <eval> seqint

%left ID
%right AFFECT AFFECT_ADD AFFECT_SUB AFFECT_MULT AFFECT_DIV AFFECT_MOD AFFECT_BIT_LEFT_SHIFT AFFECT_BIT_RIGHT_SHIFT AFFECT_BIT_AND AFFECT_BIT_XOR AFFECT_BIT_OR
%left COMMA
%right TERNARY_ASK TERNARY_CHOOSE
%left BOOL_OR
%left BOOL_AND
%left BIT_OR
%left BIT_XOR
%left BIT_AND
%left BOOL_EQUAL BOOL_DIF
%left BOOL_LESS BOOL_GREATER BOOL_LESS_OR_EQUAL BOOL_GREATER_OR_EQUAL 
%left BIT_RIGHT_SHIFT BIT_LEFT_SHIFT
%left ADD SUB
%left MULT DIV MOD
%right BIT_NOT BOOL_NOT INCREMENT DECREMENT
%left SEMICOLON

%parse-param{int *renvoi}

%%

/* ===== TODO: TO SORT ===== */

result : seqint {*renvoi = $1;}
	;

/* ===== GENERAL ===== */

programme : liext mainbody liext {std::cout << "programme" << std::endl;}
    ;
    
mainbody : maintype MAIN LEFT_PARENTHESIS mainarg RIGHT_PARENTHESIS bloc {std::cout << "mainbody" << std::endl;}
    ;
maintype : type         {std::cout << "maintype: type" << std::endl;}
    | VOID              {std::cout << "maintype : void" << std::endl;}
    | /* epsilon */     {std::cout << "maintype : epsilon" << std::endl;}
    ;
mainarg : VOID          {std::cout << "mainarg : void" << std::endl;}
    | larg              {std::cout << "mainarag : larg" << std::endl;}
    | /* epsilon */     {std::cout << "mainarg : epsilon" << std::endl;}
    ;
    
liext : liext iext  {std::cout << "liext : liext iext" << std::endl;}
    | /* epsilon */ {std::cout << "liext : epsilon" << std::endl;}
    ;
iext : deffonc    {std::cout << "iext : deffonc" << std::endl;}
    | declfonc    {std::cout << "iext : declfonc" << std::endl;}
    | SHARP     {std::cout << "iext : SHARP" << std::endl;}
    | declvar   {std::cout << "iext : declvar" << std::endl;}
    ;

/* ===== FONCTIONS ======*/

declfonc : debutfonc SEMICOLON  {std::cout << "declfonc : debutfonc ;" << std::endl;}
    ;
deffonc : debutfonc bloc        {std::cout << "deffonc : debutfonc bloc" << std::endl;}
    ;
    
debutfonc : sigfonc LEFT_PARENTHESIS larg RIGHT_PARENTHESIS     {std::cout << "debutfonc : sigfonc ( larg )" << std::endl;}
    | sigfonc LEFT_PARENTHESIS RIGHT_PARENTHESIS                {std::cout << "debutfonc : sigfonc ( )" << std::endl;}
    | sigfonc LEFT_PARENTHESIS VOID RIGHT_PARENTHESIS           {std::cout << "debutfonc : sigfonc ( VOID )" << std::endl;}
    ;
    
larg : larg COMMA arg                               {std::cout << "larg : larg , arg "<< std::endl;}
    | larg COMMA type                               {std::cout << "larg : larg , type "<< std::endl;}
    | larg COMMA type LEFT_BRACKET RIGHT_BRACKET    {std::cout << "larg : larg , type [ ] "<< std::endl;}
    | arg                                           {std::cout << "larg : arg "<< std::endl;}
    | type                                          {std::cout << "larg : type "<< std::endl;}
    | type LEFT_BRACKET RIGHT_BRACKET               {std::cout << "larg : type[] "<< std::endl;}
    ;
arg : sigvar                                {std::cout << "arg : sigvar "<< std::endl;}
    | sigvar LEFT_BRACKET RIGHT_BRACKET     {std::cout << "arg : sigvar[] "<< std::endl;}
    ;
    
appelfonc :ID LEFT_PARENTHESIS RIGHT_PARENTHESIS    {std::cout << "appelfonc : ID ( ) "<< std::endl;}
    | ID LEFT_PARENTHESIS lparam RIGHT_PARENTHESIS  {std::cout << "appelfonc : ID ( lparam )" << std::endl;}
    ;
lparam : lparam COMMA ID    {std::cout << "lparam : lparam, ID "<< std::endl;}
    | ID                    {std::cout << "lparam : ID "<< std::endl;}
    ;
    

/* ===== VARIABLES ===== */

declvar : sigvar AFFECT expr    {std::cout << "declvar : sigvar AFFECT expr "<< std::endl;}
	| sigvar                    {std::cout << "declvar : sigvar "<< std::endl;}
	;

type : CHAR {std::cout << "type : char "<< std::endl;}
	| INT32 {std::cout << "type : int32 "<< std::endl;}
	| INT64	{std::cout << "type : int64 "<< std::endl;}
	;

/* ===== IDENTIFIANT ===== */

sigvar : type ID {std::cout << "sigvar : type ID "<< std::endl;}
	;
	
sigfonc : type ID                           {std::cout << "sigfonc : type ID "<< std::endl;}
    | VOID ID                               {std::cout << "sigfonc : void ID "<< std::endl;}
    | type LEFT_BRACKET RIGHT_BRACKET ID    {std::cout << "sigfonc : type [] ID"<< std::endl;}
    | ID                                    {std::cout << "sigfonc : ID "<< std::endl;}
    ;

/* ===== INSTRUCTIONS INTERIEURES ===== */

bloc : LEFT_BRACKET seqint RIGHT_BRACKET    {std::cout << "bloc : { seqint } "<< std::endl;}
    ;

seqint : seqint iint {$$ = $2;}
	|  seqint declvar SEMICOLON {$$ = 0;}
	| /*epsilon*/ {$$ = 0;}
	;
	
iint : iintcomp SEMICOLON {$$ = $1;}
	;
	
iintcomp : iintcomp COMMA expr {$$ = $3->node->evaluate().getValue().second;}
	| expr TERNARY_ASK iintcomp TERNARY_CHOOSE iintcomp {$$ = $1->node->evaluate().getValue().second ? $3 : $5;}
	| expr {$$ = $1->node->evaluate().getValue().second; $1->node->printTree(0);}
	;

/* ===== EXPRESSION ===== */

uoperation : SUB expr {$$ = new ExprNode(std::make_shared<Constant>(-($2->node->evaluate().getValue().second)));}
	| ADD expr {$$ = new ExprNode(std::make_shared<Constant>(($2->node->evaluate().getValue().second)));}
	| BIT_NOT expr {$$ = new ExprNode(std::make_shared<Constant>(~($2->node->evaluate().getValue().second)));}
	| BOOL_NOT expr {long int i = 0;
					if($2->node->evaluate().getValue().second == 0)
							i = 1;
					$$ = new ExprNode(std::make_shared<Constant>(i));}
	;
	
expr : INT_VAL {$$ = new ExprNode(std::make_shared<Constant>($1));}
	| uoperation {$$ = $1;}
	| expr BOOL_OR expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr BOOL_AND expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr BIT_OR expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr BIT_XOR expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr BIT_AND expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr BOOL_EQUAL expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr BOOL_DIF expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr BOOL_LESS expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr BOOL_GREATER expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr BOOL_LESS_OR_EQUAL expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr BOOL_GREATER_OR_EQUAL expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr BIT_RIGHT_SHIFT expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr BIT_LEFT_SHIFT expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr ADD expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr SUB expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr MULT expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr DIV expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| expr MOD expr {$$ = new ExprNode(std::make_shared<AddExpression>($1->node, $3->node));
								delete $1;
								delete $3;}
	| LEFT_PARENTHESIS iintcomp RIGHT_PARENTHESIS {$$ = new ExprNode(std::make_shared<Constant>($2));}
	;

/* ===== AFFECTATION ===== */

affectation : ID SigneAff expr {}
	;
	
SigneAff : AFFECT {}
	| AFFECT_MULT {} 
	| AFFECT_DIV  {}
	| AFFECT_ADD  {}
	| AFFECT_SUB  {}
	| AFFECT_MOD  {}
	| AFFECT_BIT_AND  {}
	| AFFECT_BIT_OR  {}
	| AFFECT_BIT_XOR   {}
	| AFFECT_BIT_LEFT_SHIFT  {}
	| AFFECT_BIT_RIGHT_SHIFT {}
	;

/* ===== STRUCTURES ===== */ 

structure : structureif { }
	| structurewhile { }
	| structurefor { }
	;

structureif : IF LEFT_PARENTHESIS iintcomp RIGHT_PARENTHESIS iint structureelse {}
	;

structureelse : ELSE structureif {}
	| ELSE iint {}
	| /*epsilon*/ {}
	;
	
structurewhile : WHILE LEFT_PARENTHESIS iintcomp RIGHT_PARENTHESIS iint {}
	;

structurefor : FOR LEFT_PARENTHESIS ifor SEMICOLON ifor SEMICOLON ifor RIGHT_PARENTHESIS iint {}
	;
	
ifor : iintcomp {}
	| /*epsilon*/ {}
	;

%%
void yyerror(long int * param, const char * msg)
{
    std::cout << msg << std::endl;
}
