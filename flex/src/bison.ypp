%{
#include <map>
#include <string>
#include <iostream>
#include <typeinfo>

using namespace std;

extern int yylex(void);
void yyerror(long int * param, const char * msg);

%}

%union {
	char cVal;
	long int lVal;
	char * sVal;
	char * id;
	long int eval;
}

%token SHARP LINE_COM BEGIN_COM END_COM 
%token IF ELSE WHILE FOR MAIN 
%token LEFT_BRACES RIGHT_BRACES LEFT_PARENTHESIS RIGHT_PARENTHESIS 
%token LEFT_BRACKET RIGHT_BRACKET BOOL_EQUAL RETURN 
%token BOOL_DIF BOOL_LESS_OR_EQUAL BOOL_GREATER_OR_EQUAL BOOL_LESS BOOL_GREATER 
%token AFFECT_ADD AFFECT_SUB AFFECT_MULT AFFECT_DIV AFFECT_MOD TERNARY_ASK TERNARY_CHOOSE
%token INCREMENT DECREMENT AFFECT ADD SUB MULT DIV MOD 
%token BOOL_AND BOOL_OR BOOL_NOT BIT_AND BIT_OR BIT_XOR
%token BIT_NOT BIT_LEFT_SHIFT BIT_RIGHT_SHIFT 
%token VOID CHAR INT32 INT64 SEMICOLON COMMA UNEXPECTED
%token <cVal> CHAR_VAL
%token <lVal> INT_VAL
%token <sVal> CHAIN
%token <id> ID
%type <eval> expr
%type <eval> uoperation
%type <eval> iintcomp
%type <eval> iint
%type <eval> seqint

%left ID
%right AFFECT
%left COMMA
%right TERNARY_ASK TERNARY_CHOOSE
%left BOOL_OR
%left BOOL_AND
%left BIT_OR
%left BIT_XOR
%left BIT_AND
%left BOOL_EQUAL BOOL_DIF
%left BOOL_LESS BOOL_GREATER BOOL_LESS_OR_EQUAL BOOL_GREATER_OR_EQUAL 
%left BIT_RIGHT_SHIFT BIT_LEFT_SHIFT
%left ADD SUB
%left MULT DIV MOD
%right BIT_NOT BOOL_NOT
%left SEMICOLON

%parse-param{long int * renvoi}

%%

/* ===== TODO: TO SORT ===== */

result : seqint {*renvoi = $1;}
	;

/* ===== GENERAL ===== */

programmeprime : programme {cout << "programmeprime" << endl;}
    ;
programme : liext mainbody liext {cout << "programme" << endl;}
    ;
    
mainbody : maintype MAIN LEFT_PARENTHESIS mainarg RIGHT_PARENTHESIS bloc {cout << "mainbody" << endl;}
    ;
maintype : type         {cout << "maintype: type" << endl;}
    | VOID              {cout << "maintype : void" << endl;}
    | /* epsilon */     {cout << "maintype : epsilon" << endl;}
    ;
mainarg : VOID          {cout << "mainarg : void" << endl;}
    | larg              {cout << "mainarag : larg" << endl;}
    | /* epsilon */     {cout << "mainarg : epsilon" << endl;}
    ;
    
liext : liext iext  {cout << "liext : liext iext" << endl;}
    | /* epsilon */ {cout << "liext : epsilon" << endl;}
    ;
iext : deffonc    {cout << "iext : deffonc" << endl;}
    | declfonc    {cout << "iext : declfonc" << endl;}
    | SHARP     {cout << "iext : SHARP" << endl;}
    | declvar   {cout << "iext : declvar" << endl;}
    ;

/* ===== FONCTIONS ======*/

declfonc : debutfonc SEMICOLON  {cout << "declfonc : debutfonc ;" << endl;}
    ;
deffonc : debutfonc bloc        {cout << "deffonc : debutfonc bloc" << endl;}
    ;
    
debutfonc : sigfonc LEFT_PARENTHESIS larg RIGHT_PARENTHESIS     {cout << "debutfonc : sigfonc ( larg )" << endl;}
    | sigfonc LEFT_PARENTHESIS RIGHT_PARENTHESIS                {cout << "debutfonc : sigfonc ( )" << endl;}
    | sigfonc LEFT_PARENTHESIS VOID RIGHT_PARENTHESIS           {cout << "debutfonc : sigfonc ( VOID )" << endl;}
    ;
    
larg : larg COMMA arg                               {cout << "larg : larg , arg "<< endl;}
    | larg COMMA type                               {cout << "larg : larg , type "<< endl;}
    | larg COMMA type LEFT_BRACKET RIGHT_BRACKET    {cout << "larg : larg , type [ ] "<< endl;}
    | arg                                           {cout << "larg : arg "<< endl;}
    | type                                          {cout << "larg : type "<< endl;}
    | type LEFT_BRACKET RIGHT_BRACKET               {cout << "larg : type[] "<< endl;}
    ;
arg : sigvar                                {cout << "arg : sigvar "<< endl;}
    | sigvar LEFT_BRACKET RIGHT_BRACKET     {cout << "arg : sigvar[] "<< endl;}
    ;
    
appelfonc :ID LEFT_PARENTHESIS RIGHT_PARENTHESIS    {cout << "appelfonc : ID ( ) "<< endl;}
    | ID LEFT_PARENTHESIS lparam RIGHT_PARENTHESIS  {cout << "appelfonc : ID ( lparam )" << endl;}
    ;
lparam : lparam COMMA ID    {cout << "lparam : lparam, ID "<< endl;}
    | ID                    {cout << "lparam : ID "<< endl;}
    ;
    

/* ===== VARIABLES ===== */

declvar : sigvar AFFECT expr    {cout << "declvar : sigvar AFFECT expr "<< endl;}
	| sigvar                    {cout << "declvar : sigvar "<< endl;}
	;

type : CHAR {cout << "type : char "<< endl;}
	| INT32 {cout << "type : int32 "<< endl;}
	| INT64	{cout << "type : int64 "<< endl;}
	;

/* ===== IDENTIFIANT ===== */

sigvar : type ID {cout << "sigvar : type ID "<< endl;}
	;
	
sigfonc : type ID                           {cout << "sigfonc : type ID "<< endl;}
    | VOID ID                               {cout << "sigfonc : void ID "<< endl;}
    | type LEFT_BRACKET RIGHT_BRACKET ID    {cout << "sigfonc : type [] ID"<< endl;}
    | ID                                    {cout << "sigfonc : ID "<< endl;}
    ;

/* ===== INSTRUCTIONS INTERIEURES ===== */

bloc : LEFT_BRACKET seqint RIGHT_BRACKET    {cout << "bloc : { seqint } "<< endl;}
    ;

seqint : seqint iint {$$ = $2;}
	|  seqint declvar SEMICOLON {$$ = 0;}
	| /*epsilon*/ {$$ = 0;}
	;
	
iint : iintcomp SEMICOLON {$$ = $1;}
	;
	
iintcomp : iintcomp COMMA expr {$$ = $3;}
	| expr TERNARY_ASK iintcomp TERNARY_CHOOSE iintcomp {$$ = $1 ? $3 : $5;}
	| expr {$$ = $1;}
	;

/* ===== EXPRESSION ===== */

uoperation : SUB expr {$$ = -$2;}
	| ADD expr {$$ = $2;}
	| BIT_NOT expr {$$ = ~$2;}
	| BOOL_NOT expr {$$ = !$2;}
	;
	
expr : INT_VAL {$$ = $1;}
	| uoperation {$$ = $1;}
	| expr BOOL_OR expr {$$ = $1 || $3;}
	| expr BOOL_AND expr {$$ = $1 && $3;}
	| expr BIT_OR expr {$$ = $1 | $3;}
	| expr BIT_XOR expr {$$ = $1 ^ $3;}
	| expr BIT_AND expr {$$ = $1 & $3;}
	| expr BOOL_EQUAL expr {$$ = $1 == $3;}
	| expr BOOL_DIF expr {$$ = $1 != $3;}
	| expr BOOL_LESS expr {$$ = $1 < $3;}
	| expr BOOL_GREATER expr {$$ = $1 > $3;}
	| expr BOOL_LESS_OR_EQUAL expr {$$ = $1 <= $3;}
	| expr BOOL_GREATER_OR_EQUAL expr {$$ = $1 >= $3;}
	| expr BIT_RIGHT_SHIFT expr {$$ = $1 >> $3;}
	| expr BIT_LEFT_SHIFT expr {$$ = $1 << $3;}
	| expr ADD expr {$$ = $1 + $3;}
	| expr SUB expr {$$ = $1 - $3;}
	| expr MULT expr {$$ = $1 * $3;}
	| expr DIV expr {$$ = $1 / $3;}
	| expr MOD expr {$$ = $1 % $3;}
	| LEFT_PARENTHESIS iintcomp RIGHT_PARENTHESIS {$$ = $2;}
	;

/* ===== AFFECTATION ===== */

/* ===== STRUCTURES ===== */ 

%%
void yyerror(long int * param, const char * msg)
{
    cout << msg << endl;
}
